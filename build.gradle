buildscript {
    if (project.hasProperty("disconnected")) {
        dependencies {
            classpath fileTree(dir: "dependencies/buildscript", include: "*.jar")
        }
    }
    else {
        repositories {
            maven { url "https://plugins.gradle.org/m2/" }
            jcenter()
        }

        dependencies {
            classpath 'org.codehaus.groovy:groovy-json:2.4.15'
            classpath 'org.codehaus.groovy.modules.http-builder:http-builder:0.5.2'
            classpath "com.moowork.gradle:gradle-node-plugin:1.2.0"
            classpath "net.saliman:gradle-properties-plugin:1.4.6"
            classpath "com.marklogic:ml-gradle:3.3.0"
        }
    }
}

apply plugin: 'java'
apply plugin: 'net.saliman.properties'
apply plugin: "com.moowork.node"
apply plugin: "com.marklogic.ml-gradle"

configurations {
    mlcp
}

ext {
    mlDeployerAppName = "MarkLogic-Esri-Connector"
    mlDeployerDir = "build/${mlDeployerAppName}"
    mlDeployerGroup = "ML Deployer"
    mlDeployerZipFilename = "${mlDeployerAppName}.zip"
}

/*
 * If the project has the "disconnected" property defined, then we look for mlcp dependencies in a directory
 * instead of retrieving them from a repository.
 */
if (project.hasProperty("disconnected") && disconnected) {
    println "\nRUNNING IN DISCONNECTED MODE"

    dependencies {
        compile fileTree(dir: "dependencies/buildscript", include: "*.jar")

        mlcp fileTree(dir: "dependencies/mlcp", include: "*.jar")
        mlcp files("log")

        testImplementation fileTree(dir: "dependencies/testImplementation", include: "*.jar")
    }
}

/*
 * If we're not in disconnected mode, then we grab dependencies from repositories, and we define a set of tasks
 * for creating the "mlDeployer" zip file that can be used in a disconnected environment.
 */
else {
    repositories {
        maven { url "https://plugins.gradle.org/m2/" }
        maven { url "http://repository.cloudera.com/artifactory/cloudera-repos/" }
        maven { url "https://developer.marklogic.com/maven2/" }

        jcenter()
    }

    configurations {
        mlcp {
            resolutionStrategy {
                force "xml-apis:xml-apis:1.4.01"
            }
        }
    }

    dependencies {
        mlcp "com.marklogic:mlcp:9.0.3"
        mlcp "org.apache.commons:commons-csv:1.2"
        mlcp "com.marklogic:marklogic-mapreduce2:2.2.3"
        mlcp files("log")

        testImplementation 'junit:junit:4.12'
        testImplementation 'io.rest-assured:rest-assured:3.0.6'
        testImplementation 'io.rest-assured:json-path:3.0.6'
        testImplementation "com.googlecode.json-simple:json-simple:1.1.1"
    }

    task copyProjectFiles(type: Copy, group: mlDeployerGroup) {
        dependsOn = [
            "installKoop",
            "buildPlugin"
	]

        from "."
        include "build.gradle", "gradle.properties", "gradle-example.properties", "gradlew", "gradlew.bat"
        include "gradle/**"
        include "src/main/**"
        include "src/koop/**"
        include "build/koop/**"
        include "build/variancenativeplugin/**"
        include "log/**"
        include "example/**"
        into mlDeployerDir
    }

    task copyBuildScriptDependencies(type: Copy, group: mlDeployerGroup) {
        from buildscript.configurations.classpath
        into mlDeployerDir + "/dependencies/buildscript"
    }

    task copyMlcpDependencies(type: Copy, group: mlDeployerGroup) {
        from configurations.mlcp
        exclude "log4j.properties" // we copy this separately to the log dir
        into mlDeployerDir + "/dependencies/mlcp"
    }

    task addDisconnectedToGradleProperties {
        doLast {
            ant.propertyfile(file: "build/${mlDeployerAppName}/gradle.properties") {
                entry(key: "disconnected", value: "true")
            }
        }
    }

    addDisconnectedToGradleProperties.mustRunAfter copyProjectFiles

    task copyMlDeployerFiles(group: mlDeployerGroup) {
        dependsOn = [
            "copyProjectFiles",
            "copyBuildScriptDependencies",
            "copyMlcpDependencies",
            "addDisconnectedToGradleProperties"
        ]
    }

    task deleteMlDeployer(type: Delete, group: mlDeployerGroup) {
      delete mlDeployerDir, "build/${mlDeployerZipFilename}"
    }

    task buildMlDeployer (type: Zip, group: mlDeployerGroup) {
        description "Create a zip of this project's Gradle dependencies and source code so that it can be deployer without Internet access"
        dependsOn = ["deleteMlDeployer", "copyMlDeployerFiles"]
        from mlDeployerDir
        into mlDeployerAppName
        destinationDir file('build')
        archiveName mlDeployerZipFilename
    }

    copyMlDeployerFiles.mustRunAfter deleteMlDeployer
}

ext {
  mlAppConfig {
    if (project.hasProperty("mlSchemasDatabaseName")) {
      schemasDatabaseName = project.property("mlSchemasDatabaseName")
    }

    println "content database: " + contentDatabaseName
    println "schemas database: " + schemasDatabaseName
  }
}

test {
  doFirst {
    println "Running tests using the following properties:"
    println "Koop host: " + mlHost
    println "Koop port: " + koopPort
    println "REST host: " + mlHost
    println "REST port: " + mlTestRestPort
  }

  systemProperty "featureServer.host", mlHost
  systemProperty "featureServer.port", koopPort

  systemProperty "rest.port", mlTestRestPort
  systemProperty "rest.user", mlUsername
  systemProperty "rest.password", mlPassword
}

task installConnector(dependsOn: ['mlDeploy', 'installPlugin', 'configureKoop']) {
  // make sure these folders exist so we can add service descriptors and templates to them
  doFirst {
    project.file('config').mkdirs()
    project.file('config/feature-services').mkdirs()
    project.file('config/templates').mkdirs()
  }
}

task buildConnector(dependsOn: ['buildPlugin', 'installKoop'])

// Only build the plugin and install koop if we are not in disconnected mode
if (! project.hasProperty("disconnected") || ! disconnected) {
    installConnector.dependsOn("buildConnector")
    installConnector.mustRunAfter buildConnector
}

task installServices(dependsOn: ['loadFeatureServices', 'loadSchemas'])

task buildPlugin(type: Exec) {
  doFirst {
    copy {
      from 'src/main/ml-native-plugins/variance'
      into 'build/variancenativeplugin'
    }
  }

  workingDir 'build/variancenativeplugin'
  commandLine 'make'
}

task installPlugin(dependsOn: [], type: com.marklogic.gradle.task.MarkLogicTask) {
  doLast {
    // load binary to the modules database
    def client = newClient()

    def pluginZip = "build/variancenativeplugin/varianceplugin.zip"
    def pluginUri = "/native-plugins/varianceplugin.zip"

    def docMgr = client.newBinaryDocumentManager()
    docMgr.write(
      pluginUri,
      new com.marklogic.client.io.FileHandle().with(new File(pluginZip))
    )

    // eval xquery to install the plugin
    def query = '''
      xquery version "1.0-ml";
      import module namespace plugin = "http://marklogic.com/extension/plugin" at "MarkLogic/plugin/plugin.xqy";
      declare variable $plugin-uri as xs:string external;
      plugin:install-from-zip("native", fn:doc($plugin-uri)/node())
    '''
    def result = client.newServerEval()
      .xquery(query)
      .addVariable("plugin-uri", pluginUri)
      .evalAs(String.class)

    println "Installed " + result + " native plugin(s)"
  }
}

node {
  // Base URL for fetching node distributions (change if you have a mirror).
  distBaseUrl = 'https://nodejs.org/dist'

  // If true, it will download node using above parameters.
  // If false, it will try to use globally installed node.
  download = true

  // Set the work directory for unpacking node
  workDir = file("${project.buildDir}/koop/nodejs")

  // Set the work directory for NPM
  npmWorkDir = file("${project.buildDir}/koop/npm")
}

task configureKoop(type: Copy, dependsOn: []) {
  from("src/koop/config") {
    include "**"
    filter(org.apache.tools.ant.filters.ReplaceTokens, tokens: [
      KOOP_PORT : project.property("koopPort"),
      KOOP_SSL_ENABLED : project.property("koopSSLEnabled"),
      KOOP_SSL_PORT : project.property("koopSSLPort"),
      KOOP_SSL_CERT : project.property("koopSSLCert"),
      KOOP_SSL_KEY : project.property("koopSSLKey"),
      ML_HOST : mlAppConfig.host,
      ML_PORT : mlAppConfig.restPort.toString(),
      ML_USER : mlAppConfig.restAdminUsername,
      ML_PASSWORD : mlAppConfig.restAdminPassword
    ])
  }

  into "build/koop/config"
}

task installKoop(type: NpmTask, dependsOn: ['configureKoop']) {
    doFirst {
        copy {
            from "src/koop"
            include "**"
            exclude "config"
            into "build/koop"
        }
    }

    args = ['install']
    workingDir = file('build/koop')
}

import groovy.json.JsonBuilder
import groovy.json.JsonOutput
import com.marklogic.client.io.DocumentMetadataHandle
import com.marklogic.client.io.DocumentMetadataHandle.Capability

task registerKoop(type: com.marklogic.gradle.task.MarkLogicTask) {
  doLast {
    def json = new JsonBuilder()
    def config = json {
      'host' project.findProperty('koopHost') ?: mlAppConfig.host
      'port' project.property('koopSSLEnabled').toBoolean() ? project.property('koopSSLPort') : project.property('koopPort')
      'ssl' project.property('koopSSLEnabled').toBoolean()
    }
    def docUri = '/koop/config.json'
    def client = newClient()
    def docManager = client.newJSONDocumentManager()
    def metadata = new DocumentMetadataHandle()
    metadata.getCollections().addAll('http://marklogic.com/koop-config')
    metadata.getPermissions().add('esri-connector-reader', Capability.READ)
    metadata.getPermissions().add('esri-connector-writer', Capability.UPDATE)
    docManager.writeAs(docUri, metadata, json.toString())

    println 'Registered the following Koop config into ML:'
    println 'uri: ' + docUri
    println 'doc: ' + JsonOutput.prettyPrint(json.toString())
  }
}

task runKoop(type: NodeTask, dependsOn: ['registerKoop']) {
  script = file('build/koop/server.js')
  execOverrides {
    it.workingDir = 'build/koop'
    //it.standardOutput = new FileOutputStream('logs/my.log')
  }
}

task loadFeatureServices(type: com.marklogic.gradle.task.MlcpTask) {
  classpath = configurations.mlcp
  command = "IMPORT"
  port = mlAppConfig.restPort
  database = mlAppConfig.contentDatabaseName
  input_file_path = "config/feature-services"
  input_file_type = "documents"
  output_collections = "http://marklogic.com/feature-services"
  output_permissions = "rest-reader,read,rest-writer,update"
  output_uri_replace = ".*/config/,'/'"
}

task loadSchemas(type: com.marklogic.gradle.task.schemas.LoadSchemasTask, dependsOn: []) {
  ext {
    mlAppConfig {
      schemasPath = 'config/templates'
    }
  }
}

task installExampleServices(type: Copy, dependsOn: []) {
  from("example") {
    include "feature-services/**"
    include "templates/**"
  }

  into "config"
}
installExampleServices.finalizedBy installServices

task deployExampleRestModules(dependsOn: ['deployExampleQueryOptions', 'deployExampleTransforms'])

task deployExampleQueryOptions(type : com.marklogic.gradle.task.MarkLogicTask, dependsOn: []) {
  doLast {
    def client = newClient()
    def manager = client.newServerConfigManager().newQueryOptionsManager()
    def file = new File('example/ml-modules/options/example-gkg-options.xml')
    manager.writeOptions(
      'example-gkg-options',
      new com.marklogic.client.io.FileHandle().with(file)
    )
  }
}

task deployExampleTransforms(type : com.marklogic.gradle.task.MarkLogicTask, dependsOn: []) {
  doLast {
    def client = newClient()
    def manager = client.newServerConfigManager().newTransformExtensionsManager()
    def file = new File('example/ml-modules/transforms/example-gkg-transform.xqy')
    manager.writeXQueryTransform(
      'example-gkg-transform',
      new com.marklogic.client.io.FileHandle().with(file)
    )
  }
}

task loadExampleData(type: com.marklogic.gradle.task.MlcpTask) {
  classpath = configurations.mlcp
  command = "IMPORT"
  port = mlAppConfig.restPort
  database = mlAppConfig.contentDatabaseName
  input_file_path = "example/data/gkg_geojson"
  input_compressed = "true"
  output_collections = "example-gkg"
  output_permissions = "rest-reader,read,rest-writer,update"
  output_uri_replace = ".*/example/data/,'/'"
}

task loadZipCodeBoundaryData(type: com.marklogic.gradle.task.MlcpTask) {
  classpath = configurations.mlcp
  command = "IMPORT"
  port = mlAppConfig.restPort
  database = mlAppConfig.contentDatabaseName
  input_file_path = "example/data/zipcodes"
  transform_module = "/ext/transform/wrap-geojson.sjs"
  input_compressed = "true"
  batch_size = 1
  transaction_size = 1
  output_collections = "zipcodes"
  output_permissions = "rest-reader,read,rest-writer,update"
  output_uri_replace = ".*/example/data/,'/'"
}

import groovyx.net.http.HTTPBuilder
import static groovyx.net.http.Method.POST
import static groovyx.net.http.ContentType.JSON

task testExampleService(type: com.marklogic.gradle.task.MarkLogicTask) {
  doLast {
    def config = getAppConfig()
    def url = 'http://' + config.getHost() + ':' + config.getRestPort() + '/LATEST/resources/KoopProvider'

    def http = new HTTPBuilder(url)
    http.auth.basic config.getRestAdminUsername() , config.getRestAdminPassword()

    def response = http.request( POST, JSON ) { req ->
      body = [
        params : [
          id : "GDeltGKG",
          layer : 0,
          method : "query"
        ],
        query : [
          resultRecordCount : 5,
          outFields : "*"
        ]
      ]

      response.success = { resp, json ->
        println(json)
      }
    }
  }
}

